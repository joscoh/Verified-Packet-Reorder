#ifndef SORT_INCLUDED
#define SORT_INCLUDED

#include <listex.gh>

#include "tcp_semantics.gh"


/* Sorting */

// We want to say that the list (of sequence numbers) is (strongly) sorted. We define a sorted predicate and a function to insert into a sorted list. These are standard.


fixpoint bool sorted(list<int> l) {
	switch(l) {
		case nil: return true;
		case cons(h, t): return switch(t) {
					case nil: return true;
					case cons(h', t'): return cmp(h', h) >= 0 && sorted(t);
				};
	}
}
    
fixpoint list<int> insert(int x, list<int> l) {
	switch(l) {
		case nil: return cons(x, nil);
		case cons(h, t): return cmp(h, x) > 0 ? cons(x, l) : cons(h, insert(x, t));
	}
}

/* Lemmas about Sorting */

// insert preserves sortedness
lemma void insert_sorted(int x, list<int> l) 
requires sorted(l) == true && forall(l, inrange) && inrange(x) == true;
ensures sorted(insert(x, l)) == true;
{
	switch(l) {
		case nil:
		case cons(h, t): 
			if(cmp(h, x) > 0) {}
			else if(cmp(h, x) == 0) { 
				cmp_inj(h, x);
				switch(t) {
					case nil:
					case cons(h', t'):
						insert_sorted(x, t);
				}
			}
			else {
				forall_mem(h, l, inrange);
				cmp_antisym2(h, x);
				switch(t) {
					case nil:
					case cons(h', t'):
						insert_sorted(x, t);
				}
			}
	}
}
    
//If (l1 ++ l2) is sorted, then l1 is sorted and l2 is sorted

lemma void sorted_app1(list<int> l1, list<int> l2)
requires sorted(append(l1, l2)) == true;
ensures sorted(l1) == true;
{
	switch(l1) {
		case nil:
		case cons(h1, t1): 
			switch(t1) {
				case nil:
				case cons(h2, t2):
					sorted_app1(t1, l2);
			}
	}
}
    
lemma void sorted_app2(list<int> l1, list<int> l2)
requires sorted(append(l1, l2)) == true;
ensures sorted(l2) == true;
{
	switch(l1) {
		case nil:
		case cons(h1, t1): 
			switch(t1) {
				case nil:
					switch(l2) {
						case nil:
						case cons(h2, t2):
					}
				case cons(h2, t2):
					sorted_app2(t1, l2);
			}
	}
}
    
//A special case of sorted_app2 that is useful:
lemma void sorted_tail(list<int> l)
requires sorted(l) == true;
ensures sorted(tail(l)) == true;
{
	switch(l) {
		case nil:
		case cons(h, t):
			sorted_app2(cons(h, nil), t);
	}
}

/* Upper and lower bounds */

//We want to define the notion of upper and lower bounds on a list. We cannot use the included forall because we don't have partial application.
    
//upper bound
fixpoint bool ub(int x, list<int> l) {
	switch(l) {
		case nil: return true;
		case cons(h, t): return cmp(x, h) >= 0 && ub(x, t);
	}
}

//lower bound
fixpoint bool lb(int x, list<int> l) {
	switch(l) {
		case nil: return true;
		case cons(h, t): return cmp(h, x) >= 0 && lb(x, t);
	}
}

/* Results about Sorting and Bounds */
    
//If have a list upper bounded by x, and we insert y > x, then y is added to the end of the list
lemma void insert_end(list<int> l, int bound, int y)
requires ub(bound, l) && inrange(bound) && inrange(y) && forall(l, inrange) && cmp(y, bound) >= 0;
ensures insert(y, l) == append(l, cons(y, nil));
{
	switch(l) {
		case nil:
		case cons(h, t):
			forall_mem(h, l, inrange);
			cmp_ge_trans(y, bound, h);
			if(cmp(y, h) == 0) {
				cmp_inj(y, h);
			}
			else {
				cmp_antisym1(y, h);
			}
			insert_end(t, bound, y);
	}
}

//If l1 is upper bounded by x, and we insert y>x into l1 ++ l2, then we can just ignore l1

lemma void insert_app(list<int> l1, list<int> l2, int bound, int y)
requires ub(bound, l1) && inrange(bound) && inrange(y) && forall(l1, inrange) && cmp(bound, y) <= 0;
ensures insert(y, append(l1, l2)) == append(l1, insert(y, l2));
{
	switch(l1) {
		case nil: 
		case cons(h, t):
			forall_mem(h, l1, inrange);
			if(cmp(bound, y) == 0) {
				cmp_inj(bound, y);
				if(cmp(y, h) == 0) {
					cmp_inj(y, h);
				}
				if(cmp(y, h) > 0) {
					cmp_antisym1(y, h);
				}
			}
			else {
				cmp_antisym2(bound, y); //y > bound
				cmp_gt_ge_trans(y, bound, h); // so y > h
				cmp_antisym1(y, h); // so h < y
			}
			insert_app(t, l2, bound, y);
			
	}	
}

/* Miscellaneous Results about Lists */

lemma void length_pos<t>(list<t> l)
requires l != nil;
ensures 1 <= length(l);
{
	switch(l) {
		case nil:
		case cons(h, tl): 
			switch(tl) {
				case nil:
				case cons(h1, t1): length_pos(tl);
			}
	}
}

lemma void head_take<t>(list<t> l, int n)
requires 1 <= n && l != nil;
ensures head(take(n, l)) == head(l);
{
	switch(l) {
		case nil:
		case cons(h, t):
	}
}
	
lemma void head_tail<t>(list<t> l)
requires l != nil;
ensures l == cons(head(l), tail(l));
{
	switch(l) {
		case nil:
		case cons(h, t):
	}
}

#endif