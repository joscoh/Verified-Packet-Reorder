#ifndef SORT_INCLUDED
#define SORT_INCLUDED

#include <listex.gh>

/* Comparison */

// We cannot faithfully prove the cmp function correct because it uses intentional overflow, which Verifast cannot handle. We could
// provide a definition which is correct, but we don't need the definition anywhere; we only need to know that this function satisfies
// a few properties. We prove these properties correct in Coq based on the C code, since VST can handle overflow.
// Therefore, we leave cmp opaque and give the needed properties as axioms.

fixpoint int cmp(int a, int b);

// cmp is not a true comparison because of wraparound. But it works correctly if, for all elements x and y, |x-y| < 2^31 or for all x, y, |x-y| >= 2^31
// (we proved this in Coq). To make things simpler, we assume here that all elements are in the range [0, 2^31-1] (ie: positive signed integers).

// x is in the range [0, 2^31-1]
fixpoint bool inrange(int x) {
	return (0 <= x) && (x <= 2147483647);
}

lemma void cmp_same(int a);
requires true;
ensures cmp(a, a) == 0;

lemma void cmp_inj(int a, int b);
requires (0 <= a) && (a <= 4294967295) && (0 <= b) && (b <= 4294967295) && cmp(a,b) == 0;
ensures a == b;

lemma void cmp_antisym1(int a, int b);
requires inrange(a) == true && inrange(b) == true && cmp(a,b) > 0;
ensures cmp(b,a) < 0; 

lemma void cmp_antisym2(int a, int b);
requires inrange(a) == true && inrange(b) == true && cmp(a,b) < 0;
ensures cmp(b,a) > 0; 

lemma void cmp_ge_trans(int a, int b, int c);
requires inrange(a) == true && inrange(b) == true && inrange(c) == true && cmp(a, b) >= 0 && cmp(b, c) >= 0;
ensures cmp(a, c) >= 0; 

lemma void cmp_gt_trans(int a, int b, int c);
requires inrange(a) == true && inrange(b) == true && inrange(c) == true && cmp(a, b) > 0 && cmp(b, c) > 0;
ensures cmp(a, c) > 0; 

//We can prove this one
lemma void cmp_gt_ge_trans(int a, int b, int c)
requires inrange(a) == true && inrange(b) == true && inrange(c) == true && cmp(a, b) > 0 && cmp(b, c) >= 0;
ensures cmp(a, c) > 0; 
{
	if(cmp(b, c) == 0) {
		cmp_inj(b, c);
	} 
	else {
		cmp_gt_trans(a, b, c);
	}
	
	
}

/* Sorting */


// We want to say that the list (of sequence numbers) is (strongly) sorted. We define a sorted predicate and a function to insert into a sorted list. These are standard.

fixpoint bool sorted(list<int> l) {
	switch(l) {
		case nil: return true;
		case cons(h, t): return switch(t) {
					case nil: return true;
					case cons(h', t'): return cmp(h', h) > 0 && sorted(t);
				};
	}
}
    
fixpoint list<int> insert(int x, list<int> l) {
	switch(l) {
		case nil: return cons(x, nil);
		case cons(h, t): return cmp(h, x) > 0 ? cons(x, l) : cons(h, insert(x, t));
	}
}

/* Lemmas about Sorting */

// insert preserves sortedness
lemma void insert_sorted(int x, list<int> l) 
requires sorted(l) == true && forall(l, inrange) && !mem(x, l) && inrange(x) == true;
ensures sorted(insert(x, l)) == true;
{
	switch(l) {
		case nil:
		case cons(h, t): 
			if(cmp(h, x) > 0) {}
			else if(cmp(h, x) == 0) { 
				cmp_inj(h, x);
			}
			else {
				forall_mem(h, l, inrange);
				cmp_antisym2(h, x);
				switch(t) {
					case nil:
					case cons(h', t'):
						insert_sorted(x, t);
				}
			}
	}
}
    
//If (l1 ++ l2) is sorted, then l1 is sorted and l2 is sorted

lemma void sorted_app1(list<int> l1, list<int> l2)
requires sorted(append(l1, l2)) == true;
ensures sorted(l1) == true;
{
	switch(l1) {
		case nil:
		case cons(h1, t1): 
			switch(t1) {
				case nil:
				case cons(h2, t2):
					sorted_app1(t1, l2);
			}
	}
}
    
lemma void sorted_app2(list<int> l1, list<int> l2)
requires sorted(append(l1, l2)) == true;
ensures sorted(l2) == true;
{
	switch(l1) {
		case nil:
		case cons(h1, t1): 
			switch(t1) {
				case nil:
					switch(l2) {
						case nil:
						case cons(h2, t2):
					}
				case cons(h2, t2):
					sorted_app2(t1, l2);
			}
	}
}
    
//A special case of sorted_app2 that is useful:
lemma void sorted_tail(list<int> l)
requires sorted(l) == true;
ensures sorted(tail(l)) == true;
{
	switch(l) {
		case nil:
		case cons(h, t):
			sorted_app2(cons(h, nil), t);
	}
}

/* Upper and lower bounds */

//We want to define the notion of upper and lower bounds on a list. We cannot use the included forall because we don't have partial application.
    
//upper bound
fixpoint bool ub(int x, list<int> l) {
	switch(l) {
		case nil: return true;
		case cons(h, t): return cmp(x, h) >= 0 && ub(x, t);
	}
}

//lower bound
fixpoint bool lb(int x, list<int> l) {
	switch(l) {
		case nil: return true;
		case cons(h, t): return cmp(h, x) >= 0 && lb(x, t);
	}
}

/* Results about Sorting and Bounds */
    
//If have a list upper bounded by x, and we insert y > x, then y is added to the end of the list
lemma void insert_end(list<int> l, int bound, int y)
requires ub(bound, l) && inrange(bound) && inrange(y) && forall(l, inrange) && cmp(y, bound) >= 0;
ensures insert(y, l) == append(l, cons(y, nil));
{
	switch(l) {
		case nil:
		case cons(h, t):
			forall_mem(h, l, inrange);
			cmp_ge_trans(y, bound, h);
			if(cmp(y, h) == 0) {
				cmp_inj(y, h);
			}
			else {
				cmp_antisym1(y, h);
			}
			insert_end(t, bound, y);
	}
}

//If l1 is upper bounded by x, and we insert y>x into l1 ++ l2, then we can just ignore l1

lemma void insert_app(list<int> l1, list<int> l2, int bound, int y)
requires ub(bound, l1) && inrange(bound) && inrange(y) && forall(l1, inrange) && cmp(bound, y) < 0;
ensures insert(y, append(l1, l2)) == append(l1, insert(y, l2));
{
	switch(l1) {
		case nil: 
		case cons(h, t):
			forall_mem(h, l1, inrange);
			cmp_antisym2(bound, y);
			cmp_gt_ge_trans(y, bound, h);
			insert_app(t, l2, bound, y);
			cmp_antisym1(y, h);
	}	
}

/* Miscellaneous Results about Lists */

lemma void length_pos<t>(list<t> l)
requires l != nil;
ensures 1 <= length(l);
{
	switch(l) {
		case nil:
		case cons(h, tl): 
			switch(tl) {
				case nil:
				case cons(h1, t1): length_pos(tl);
			}
	}
}

lemma void head_take<t>(list<t> l, int n)
requires 1 <= n && l != nil;
ensures head(take(n, l)) == head(l);
{
	switch(l) {
		case nil:
		case cons(h, t):
	}
}
	
lemma void head_tail<t>(list<t> l)
requires l != nil;
ensures l == cons(head(l), tail(l));
{
	switch(l) {
		case nil:
		case cons(h, t):
	}
}

#endif